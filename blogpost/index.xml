<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogpost-rsses on RedElastic</title>
    <link>http://redelastic.com/blogpost/index.xml</link>
    <description>Recent content in Blogpost-rsses on RedElastic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 19 Dec 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://redelastic.com/blogpost/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Play Concurrency: Under the Hood</title>
      <link>http://redelastic.com/blog/play-concurrency</link>
      <pubDate>Mon, 19 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://redelastic.com/blog/play-concurrency</guid>
      <description>

&lt;p&gt;Play is an MVC framework for the JVM that breaks from the servlet standard, which allocates a thread-per-request, and embraces fully reactive programming through the use of &lt;em&gt;futures&lt;/em&gt; for asynchronous programming and &lt;em&gt;work stealing&lt;/em&gt; for maximizing available threads.&lt;/p&gt;

&lt;p&gt;Not only does Play have some extreme performance advantages over MVC frameworks like Spring that employ thread-based concurrency with synchronous, blocking operations, but it’s quite simple to get started with Play as the programming style is so familiar.&lt;/p&gt;

&lt;h2 id=&#34;futures-actors-and-work-stealing&#34;&gt;Futures, actors, and work stealing&lt;/h2&gt;

&lt;p&gt;A combination of &lt;em&gt;futures&lt;/em&gt;, &lt;em&gt;actors&lt;/em&gt;, and &lt;em&gt;work stealing&lt;/em&gt; makes Play one of the most flexible, performant, and resilient MVC frameworks in the industry.&lt;/p&gt;

&lt;p&gt;Play employs &lt;em&gt;futures&lt;/em&gt;, which can be considered a form of event-driven concurrency. This is nothing novel, many frameworks such as Node.js feature event-driven concurrency as well.&lt;/p&gt;

&lt;p&gt;The clever innovation in Play is the use of &lt;em&gt;work stealing&lt;/em&gt;. The combination of work stealing and statelessness make Play scalable in both directions, up and out.&lt;/p&gt;

&lt;p&gt;In order to understand what futures and work stealing bring to the table, we need to start from the bottom and work our way up. All example Play code is written in Scala, although Play also has an excellent API for Java.&lt;/p&gt;

&lt;h3 id=&#34;work-stealing&#34;&gt;Work stealing&lt;/h3&gt;

&lt;p&gt;Work stealing is implemented with the &lt;a href=&#34;JSR-166&#34;&gt;ForkJoin Framework&lt;/a&gt;. It was first added to Java 7 and refined in Java 8. Fork/join makes it more efficient for Java developers to write concurrent/parallel code in Java and avoid the complexities of locks, monitors, and synchronization.&lt;/p&gt;

&lt;p&gt;Let’s explore parallelism as two distinct categories, divide-conquer and work stealing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Divide-conquer&lt;/strong&gt; is the process of taking a long-running computation, splitting it up, and executing both sides of the computation in parallel before joining the results together.  If we apply the same approach recursively, we can continue to divide our work into smaller and smaller halves until the individual tasks become small enough to compute.&lt;/p&gt;

&lt;p&gt;For instance, if we’re summing a list of integers, we can decide that the largest list we want to work with has 1,000 elements. If the original list has 10,000 elements, we first split the list in half, and split those halves in half, and keep splitting until the maximum list size we work with has 1,000 elements. At that point we can execute the tasks in parallel and join the results together.&lt;/p&gt;

&lt;p&gt;Divide-conquer makes efficient use of multi-core processors because creating smaller tasks and handing them off to the runtime makes it easier for the runtime to &lt;em&gt;schedule&lt;/em&gt; the tasks according to the overall capacity of your system. For instance, if the CPU is mostly idle, the tasks can be spread across available cores and run in parallel, whereas if the CPU is already busy with other things the CPU can decide to interleave smaller tasks with other operations happening on the CPU so all programs make a reasonable amount of progress concurrently without hanging.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Work stealing&lt;/strong&gt; can be considered a subset of scheduling. Fork/join implements a work-stealing technique when scheduling tasks that can be broadly described as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The fork/join framework is distinct because it uses a work-stealing algorithm. Worker threads that run out of things to do can steal tasks from other threads that are still busy.&lt;/p&gt;

&lt;p&gt;— &lt;a href=&#34;http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html&#34;&gt;http://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fork/join framework is mostly abstracted away from Play developers, but it’s helpful to understand how it works when tuning Play for performance.&lt;/p&gt;

&lt;p&gt;Parallelism building blocks in fork/join are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ForkJoinPool:&lt;/strong&gt; An instance of this class is used to run all of your fork-join tasks&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RecursiveTask&amp;lt;V&amp;gt;:&lt;/strong&gt; Run a subclass of this in a pool and have it return a result&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RecursiveAction:&lt;/strong&gt; Run a subclass of this in a pool but without returning a result&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ForkJoinTask&amp;lt;V&amp;gt;:&lt;/strong&gt; Superclass of RecursiveTask&amp;lt;V&amp;gt; and RecursiveAction; fork and join are methods defined in this class&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;actions-and-futures&#34;&gt;Actions and Futures&lt;/h3&gt;

&lt;p&gt;The core of the developer experience in Play are &lt;em&gt;actions&lt;/em&gt;, which are tasks that are executed when an incoming request is routed to that action based on URI matching. An action can be defined as synchronous or asynchronous.&lt;/p&gt;

&lt;p&gt;Because Play is built on top of Scala, a hybrid object/functional programming language, actions themselves are simply anonymous functions that return an &lt;code&gt;HttpResponse&lt;/code&gt; (synchronous) or a &lt;code&gt;Future[HttpResponse]&lt;/code&gt; (asynchronous).&lt;/p&gt;

&lt;p&gt;The following action definition is synchronous:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;def&lt;/span&gt; joinGame &lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;=&lt;/span&gt; Action { &lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;implicit&lt;/span&gt; request &lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt;
    Ok(...)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The following is asynchronous:&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;def&lt;/span&gt; joinGame &lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;=&lt;/span&gt; Action.async { &lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;implicit&lt;/span&gt; request &lt;span style=&#34;color: #000080; font-weight: bold&#34;&gt;=&amp;gt;&lt;/span&gt;
    Future(Ok(...))
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;When we build Play applications, under the hood we can consider a &lt;code&gt;Future&lt;/code&gt; to be an abstraction on top of &lt;code&gt;ForkJoinTask&amp;lt;V&amp;gt;&lt;/code&gt;. Understanding this fact becomes important when creating and tuning new &lt;em&gt;execution contexts&lt;/em&gt;. In the above code, we can see that an async action roughly maps to a &lt;code&gt;RecursiveAction&lt;/code&gt; that is executed asynchronously on a &lt;code&gt;ForkJoinPool&lt;/code&gt;, whereas a synchronous action is a simple thread that is executed on a thread pool.&lt;/p&gt;

&lt;p&gt;The syntactic difference is subtle but the runtime difference is profound. If we do not declare our actions as async, Play does not leverage fork/join; it assigns a thread to the lifecycle of the request and performs all subtasks synchronously. In situations where you may be tempted to pin a request to a thread in this fashion, you’re almost always better moving that work to Akka where you have significantly more options for customizing the way work is performed.&lt;/p&gt;

&lt;p&gt;Play itself is the perfect technology to use as a &lt;em&gt;stateless&lt;/em&gt; API gateway or RESTful API layer. It also integrates very well with front-end technologies such as AngularJS and React. Although it comes with support for rendering HTML out of the box, it is also perfectly happy serving up endpoints that render other formats such as JSON or XML.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Principle of Least Power with Play</title>
      <link>http://redelastic.com/blog/principle-of-least-power</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>http://redelastic.com/blog/principle-of-least-power</guid>
      <description>&lt;p&gt;Language zealotry is not new, it’s been going on since the beginning of personal computers. Apple shipped with BASIC, and from the very beginning was held in contempt by Unix programmers. They didn’t recognize the power of simplicity - that is, a programming language so simple that entire language could be held in the head of a developer.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Apple was founded in 1977, and advances came with almost unbelievable rapidity in the years that followed. The potential of microcomputers was clear, and attracted yet another generation of bright young hackers. Their language was BASIC, so primitive that PDP-10 partisans and Unix aficionados both considered it beneath contempt.&lt;/p&gt;

&lt;p&gt;— &lt;a href=&#34;http://www.catb.org/esr/writings/cathedral-bazaar/&#34;&gt;The Cathedral and the Bazaar&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the biggest pressures in professional software development is the constant battle against the feeling of falling behind. Some technologists exploit this insecurity to push increasingly overly complex technologies to solve the challenges at hand.&lt;/p&gt;

&lt;p&gt;An emerging line of thinking in the Scala community is to embrace the &lt;em&gt;principle of least power&lt;/em&gt;. While advanced languages such as Scala can offer a competitive advantage, they are also riddled with potential landmines because of their vast flexibility. From being used as a &lt;em&gt;better Java&lt;/em&gt; to used in &lt;em&gt;purely functional polymorphic style&lt;/em&gt;, the range of complexity and styles in production Scala codebases is vast.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a choice of solutions, pick the least powerful solution capable of solving your problem.&lt;/p&gt;

&lt;p&gt;— Li Haoyi, &lt;a href=&#34;http://www.lihaoyi.com/post/StrategicScalaStylePrincipleofLeastPower.html&#34;&gt;Strategic Scala Style&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;One of the qualities that originally attracted me to the Lightbend platform was the balance between power and simplicity. The Play framework…&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Proprietary-Unix players proved so ponderous, so blind, and so inept at marketing that Microsoft was able to grab away a large part of their market with the shockingly inferior technology of its Windows operating system.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Cloud Revolution</title>
      <link>http://redelastic.com/blog/the-cloud-revolution</link>
      <pubDate>Thu, 06 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>http://redelastic.com/blog/the-cloud-revolution</guid>
      <description>

&lt;p&gt;Server-side development is rapidly moving into the world of declarative and functional programming to support a major shift in industry. Even Java 8 now supports functional programming constructs such as functional collections. Libraries such as &lt;a href=&#34;http://www.javaslang.io/&#34;&gt;Javaslang&lt;/a&gt; are bringing even more powerful functional programming to Java developers.&lt;/p&gt;

&lt;div class=&#34;highlight&#34; style=&#34;background: #ffffff&#34;&gt;&lt;pre style=&#34;line-height: 125%&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span style=&#34;color: #008800; font-style: italic&#34;&gt;/* filtering by age and converting to people to names in Java 8 with Javaslang */&lt;/span&gt;
List&amp;lt;String&amp;gt; names = persons
    .&lt;span style=&#34;color: #FF0000&#34;&gt;filter&lt;/span&gt;(p -&amp;gt; p.&lt;span style=&#34;color: #FF0000&#34;&gt;age&lt;/span&gt; &amp;gt; &lt;span style=&#34;color: #0000FF&#34;&gt;12&lt;/span&gt;)
    .&lt;span style=&#34;color: #FF0000&#34;&gt;map&lt;/span&gt;(Person::getName);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This shift towards functional programming is not accidental.&lt;/p&gt;

&lt;h2 id=&#34;from-code-to-data&#34;&gt;From Code to Data&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;When you get to where the f*** I&amp;rsquo;m at, you gotta remind &amp;lsquo;em about where you been.&lt;/p&gt;

&lt;p&gt;— Lil Wayne&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In 2006, Ruby on Rails gave PHP developers a reasonable alternative to web development. Ruby on Rails in particular inspired a whole legion of programmers to rethink standards like the JCP and build sane frameworks rather than work within the confines of slow-moving standards designed by committee.&lt;/p&gt;

&lt;p&gt;While this was happening, Amazon was quietly revolutionizing the data center.&lt;/p&gt;

&lt;p&gt;Frameworks were initially slow to catch on, continuing to focus on developer productivity while more or less ignoring the profound architectural implications of this new breed of data center. Services like &lt;a href=&#34;https://www.heroku.com/&#34;&gt;Heroku&lt;/a&gt; and &lt;a href=&#34;https://aws.amazon.com/&#34;&gt;AWS&lt;/a&gt; began to bring unlimited resources on-tap to developers. While on-tap resources brought tremendous flexibility to developers, they also introduced a host of situations that popular frameworks of the day were not equipped to deal with.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s be clear; the cloud is just a fancy phrase that translates to &lt;em&gt;”other people’s computers”&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The main issue affecting cloud architectures is that a machine in the cloud can disappear at any time and for any reason. When you entrust your applications to computers that you don’t own, expect the unexpected; this is the core reason why monolithic-style frameworks that hold state on the server ill-equipped as a cloud-based technology. The glue between servers — &lt;em&gt;the network&lt;/em&gt; — has become more robust than the servers themselves. This pushes resilience concerns off of servers and onto the glue that connects servers together. If we consider the network as the pipes, we also need a fabric that sits on top which adds context to the connections, what we refer to as a &lt;em&gt;cluster manager&lt;/em&gt;. If we don’t expect our servers to stay alive, the very least we require is that if they die they spin back up in a consistent state. This is trivial for stateless applications, but non-trivial for stateful applications.&lt;/p&gt;

&lt;h2 id=&#34;cloud-survival-guide&#34;&gt;Cloud Survival Guide&lt;/h2&gt;

&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>